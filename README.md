# Yandex ToDo Application
### Made by [@ricardomilozio](https://t.me/ricardomilozio)

## Project *killer-features*
- Swiping both left & right
    - Swiping **left** to delete. Item will be removed from Recycler View. Trash icon will be drawn at the red background while swiping.
    - Swiping **right** to check. Item **isDone** param will be inverted & item will be recreated by the RecyclerView. Check box icon will be drawn at the green background while swiping.
- Both **Day** and **Night** Themes supported
- **Responsive UI**
    - Text becomes strikethrough when the task is completed and vice versa
    - Fragment navigation implemented
    - Ripple effect
    - Navigation Animations
    - Collapsing toolbar
- Dagger DI
- Room Database
- Retrofit
- Server synchronization

## Homework [1] ✅
В моей реализации есть пара особенностей.
1. Дизайн не как на Figma. Но это нормально, Figma нужна была только для вдохновения)
2. Service package сделана по факту для мока данных. Пока LiveData лежит в VM. Но я это исправлю как подключу ROOM.
3. Навигация переживает поворот экрана, но данные во фрагменты нет. Вернее переживают, но не все. Тоже пофикшу при подключении ROOM.
4. TodoItemsRepository сделан для мока данных! Реализован как singleton. Но пока только мокает данные! Данные добавляются, recycler view перерисовывает, все классно, но LiveData живет в ViewModel. Просто поэкспериментировал с observable list в LiveData с помощью extensions. Поэтому и не вызывается метод в ItemsTodoRepository :)


## Homework [1] - refactoring
В соответствии с советами ревьювера (прекрасными советами, между прочим) сделал:
1. Переход на Flow
2. Баги в UI - теперь DatePickerDialog, а не вылезающий календарь
3. Переход в Clean Architecture
4. Дизайн по Figma
5. Collapsing Toolbar (с багом открытия после navigate Up - но пофикшу, обещаю...)
6. Diff Util для Recycler View


## Homework [2] ✅
Вышло очень косячно имхо. Все сделано, но есть баги в UI.
1. Таска при свайпе может уехать навечно за границы экрана -> причина: рассинхрон с сервером
2. Таски при изменении состояния (тот же свайп) начинают хаотично переставляться -> причина: попытка сортировки по дате изменения/создания от поздней к ранней. Но сервер возвращает в хаотичном порядке, из-за момента, когда показываются старые данные и еще не прогрузились новые, ресайклер начинает переставлять данные по алгоритму DiffUtil.
3. Колапсинг тулбар иногда не колапсинг...

Ретрофит я прикручивал в последний день (ночью), поэтому вся эта часть выглядит так, будто ее писал психопат, сорри...
Но! Есть и хорошие новости! Сделан Dagger DI (сидел разбирался после лекции). Реализована чистая архитектура (может, в коде она немного грязная...). Обработка данных вся на Kotlin Flow (раньше делал только на LiveData и State из Jetpack). Буду рад любым советам!

Если есть возможность, сделайте акцент, пожалуйста, на TaskRepository.kt
Я не совсем понимаю каким образом нам нужно синхронизировать задачи одновременно с бэкенда и с нашей БД. Сейчас сделана полумера - все сваливается в один Flow, считаются последние ревизии, у кого больше - тот победил.


## Homework [3] ✅
1. Clean Architecture. В целом структура проекта разбита на 3 слоя - presenter, domain, data. Взаимодействие между слоями реализовано с помощью юзкейсов. Старался по максимуму выстраивать взаимодействие на репозиториях.
2. Возможно, возникнут вопросы, зачем столько фрагментов... Без разбиения на отдельные фрагменты код, который "оживляет" верстку в xml разросся бы до ужасающих значений. Он и сейчас устрашающий. Но хотя бы не очень большой. Но функция с настройкой RecyclerView знаю, огромная. Но я ничего не могу с ней поделать. Дробить на компоненты? Ее будет столь же много, просто она будет размазана на много частей.
3. Возможно, стоило бы разбить на несколько вью моделей... Но пока не испытывал в этом необходимости. Приму любые советы и предложения)
4. Dagger 2 DI. Разбито на Subcomponents и реализованы Custom Scopes, где это возможно. Имхо не вижу смысла в разделении на сабкомпоненты в таком маленьком приложении. Хватило бы одного компонента...
5. Благодаря использованию интерфейсов удалось по минимуму использовать @Provides, который генерит больше кода, чем @Binds.
6. Использованы свои @Qualifier для разграничения объектов того же класса, но разного значения.
7. SyncWorker для бэкграундной синхронизации раз в 15 минут. Зачем синхронизировать какие-то таски раз в 8 часов?)
8. Зачем синхронизация при появлении интернета, если это либо заметит SyncWorker или само приложение? Фича - динамическая синхронизация во время работы пользователя.

# Bugs
1. Иногда скрывается дата дедлайна при частом тыкании на кнопку скрытия выполненных задач. Возможно ошибка в ViewHolder. Пока не проверял.
2. Колапсинг тулбар при возвращении на фрагмент ВСЕГДА открыт, даже если при выполнении навигации из этого фрагмента он был скрыт. Вообще, не баг, а фича... Но можно пофиксить стейтом.
3. Синхронизация может работать через раз, но это беды сервера. Чуть что - тыкайте кнопку синхронизации и будут самые актуальные значения. Но при любом 400 от сервера на изменение/удаление/добавление таски начинается закадровая синхронизация. Поэтому ручная синхронизация может не потребоваться.

